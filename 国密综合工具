package PasteFinalWork;
import java.awt.BorderLayout;
import java.awt.EventQueue;
import java.awt.HeadlessException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.Signature;
import java.security.UnrecoverableEntryException;
import java.security.KeyStore.PrivateKeyEntry;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.spec.ECGenParameterSpec;
import java.util.Calendar;
import java.util.Date;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.swing.ButtonGroup;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPasswordField;
import javax.swing.JTabbedPane;
import javax.swing.JTextField;
import javax.swing.border.EmptyBorder;
import javax.xml.crypto.dsig.XMLSignature.SignatureValue;

import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.BasicConstraints;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.util.encoders.Hex;

public class FinalWork extends JFrame {

	private static final long serialVersionUID = 1L;
	private JPanel contentPane;
	private JTextField textFieldHashInput;
	private JTextField textFieldHashSM3;
	private JButton btnHashOpenFile;
	private JTextField textFieldCipherFileName;
	private JPasswordField passwordFieldCipher;
	private final ButtonGroup buttonGroup = new ButtonGroup();
	private JTextField textFieldSignatureInPut;
	private JTextField textFieldSignatureValueFile;
	private JTextField textFieldSignatureKeyFile;

	/**
	 * Launch the application.
	 */
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					FinalWork frame = new FinalWork();
					frame.setVisible(true);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}

	/**
	 * Create the frame.
	 */
	public FinalWork() {
		setTitle("国密综合工具");
		setResizable(false);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setBounds(100, 100, 628, 501);
		contentPane = new JPanel();
		contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));

		setContentPane(contentPane);
		contentPane.setLayout(new BorderLayout(0, 0));
		
		JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
		contentPane.add(tabbedPane, BorderLayout.CENTER);
		
		JPanel panelHash = new JPanel();
		tabbedPane.addTab("哈希", null, panelHash, null);
		panelHash.setLayout(null);
		
		JComboBox comboBox = new JComboBox();
		comboBox.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if(comboBox.getSelectedIndex() == 0) {
					btnHashOpenFile.setVisible(true);
					// 如果被选中的项为0（即File），btnOpenFile出现
				} else {
					btnHashOpenFile.setVisible(false);
					// 反之，btnOpenFile消失
				}
			}
		});
		comboBox.setModel(new DefaultComboBoxModel(new String[] {"File", "String"}));
		comboBox.setBounds(30, 20, 74, 20);
		panelHash.add(comboBox);
		
		textFieldHashInput = new JTextField();
		textFieldHashInput.setBounds(138, 21, 374, 18);
		panelHash.add(textFieldHashInput);
		textFieldHashInput.setColumns(10);
		
		textFieldHashSM3 = new JTextField();
		textFieldHashSM3.setEditable(false);
		textFieldHashSM3.setBounds(138, 99, 374, 18);
		panelHash.add(textFieldHashSM3);
		textFieldHashSM3.setColumns(10);
		
		btnHashOpenFile = new JButton("...");
		btnHashOpenFile.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				JFileChooser chooser = new JFileChooser();
				// 定义文件选择器
				if (chooser.showOpenDialog(FinalWork.this) == JFileChooser.APPROVE_OPTION) {
				File file = chooser.getSelectedFile();
				if (!file.isDirectory()) {
					// 如果file不是目录；
					textFieldHashInput.setText(file.getAbsolutePath());
					// 文件全路径返回单行文本框
				}
				}
			}
		});
		btnHashOpenFile.setBounds(539, 20, 32, 21);
		panelHash.add(btnHashOpenFile);
		
		JCheckBox chckbxHashSM3 = new JCheckBox("SM3");
		chckbxHashSM3.setBounds(33, 98, 80, 21);
		panelHash.add(chckbxHashSM3);
		
		JButton btnHashCalculate = new JButton("计算");
		btnHashCalculate.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				Security.addProvider(new BouncyCastleProvider());
				// 添加安全服务提供者
				String[] HashAlgs = {"SM3"};
				// 定义字符串HasAlgs数组
				JCheckBox[] checkboxes = {chckbxHashSM3};
				// 定义checkboxes数组 
				JTextField[] textFields = {textFieldHashSM3};
				// 定义textFields数组
				for (JTextField textField : textFields) {
					textField.setText("");
					// 对textFields中的单行文本框清空
				}
				if (comboBox.getSelectedIndex() == 0) { // 计算并显示文件的HASH值
					for (int i = 0;i < checkboxes.length; i++) {
						// 对checkboxes进行遍历
						if (checkboxes[i].isSelected()) {
							// 对checkboxes进行遍历
							try {
								MessageDigest md = MessageDigest.getInstance(HashAlgs[i]);
								// 创建MessageDige对象，对应HASH算法找HashAlgs的第i个元素
								try (FileInputStream fis = new FileInputStream(textFieldHashInput.getText())){
									// 创建文件输入流
									byte[] buffer = new byte[1024];
									// 定义字节数组，每次最多读1024字节
									int n = -1;
									while ((n = fis.read(buffer)) != -1) {
										md.update(buffer, 0, n);
										// 读多少，update多少
									}
									byte[] digest = md.digest();
									// 找md执行difest方法，返回消息摘要值
									textFields[i].setText(Hex.toHexString(digest));
									// 输出于textFields第i个元素内
								}
							} catch (NoSuchAlgorithmException e1) {
								e1.printStackTrace();
							} catch (FileNotFoundException e1) {
								e1.printStackTrace();
							} catch (IOException e1) {
								e1.printStackTrace();
							}
						}
					}
				} else { // 计算字符串的HASH值
					for (int i = 0;i < checkboxes.length; i++) {
						// 对checkboxes进行遍历
						if (checkboxes[i].isSelected()) {
							// 对checkboxes进行遍历
							byte[] message = textFieldHashInput.getText().getBytes();
							// 获取字符串，转成字节数组
							try {
								MessageDigest md = MessageDigest.getInstance(HashAlgs[i]);
								// 创建MessageDige对象，对应HASH算法找HashAlgs的第i个元素
								md.update(message);
								textFields[i].setText(Hex.toHexString(md.digest()));
								// 输出于textFields第i个元素内
							} catch (NoSuchAlgorithmException e1) {
								e1.printStackTrace();
							}
							
						}
					}
				}
			}
		});
		btnHashCalculate.setBounds(83, 185, 89, 21);
		panelHash.add(btnHashCalculate);
		
		JButton btnHashClear = new JButton("清空");
		btnHashClear.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				textFieldHashInput.setText("");
				// 清空输入文本框
				textFieldHashSM3.setText("");
				// 清空SM3文本框
			}
		});
		btnHashClear.setBounds(255, 185, 89, 21);
		panelHash.add(btnHashClear);
		
		JButton btnHashClose = new JButton("关闭");
		btnHashClose.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				System.exit(0); // 关闭程序
			}
		});
		btnHashClose.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			}
		});
		btnHashClose.setBounds(427, 185, 89, 21);
		panelHash.add(btnHashClose);
		
		JPanel panelCipher = new JPanel();
		tabbedPane.addTab("加密", null, panelCipher, null);
		panelCipher.setLayout(null);
		
		JButton btnCipherEncrypt = new JButton("加密");
		btnCipherEncrypt.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				Security.addProvider(new BouncyCastleProvider());
				// 添加安全服务提供者
				String plainFileName = textFieldCipherFileName.getText();
				// 获得明文文件名
				if (plainFileName.length() > 0) {
					char[] password = passwordFieldCipher.getPassword();
					// 获得口令
					JFileChooser chooser = new JFileChooser(".");
					if (chooser.showSaveDialog(FinalWork.this) == JFileChooser.APPROVE_OPTION) {
						String encyptedFileName = chooser.getSelectedFile().getAbsolutePath();
						// 获得密文文件名
						
						// 获取用户选择的加密强度，即密钥长度
						int keyLength = 16;
						// 定义密钥长度默认为16
						encrypt(plainFileName, encyptedFileName, password, keyLength);
					}
				}
			}
		});
		btnCipherEncrypt.setBounds(140, 288, 89, 21);
		panelCipher.add(btnCipherEncrypt);
		
		JButton btnCipherDecrypt = new JButton("解密");
		btnCipherDecrypt.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				Security.addProvider(new BouncyCastleProvider());
				// 添加安全服务提供者
				String encryptedFileName = textFieldCipherFileName.getText();
				// 获得密文文件名
				if (encryptedFileName.length() > 0) {
					// 如果长度大于零
					char[] password = passwordFieldCipher.getPassword();
					// 获得口令
					JFileChooser chooser = new JFileChooser(".");
					if (chooser.showSaveDialog(FinalWork.this) == JFileChooser.APPROVE_OPTION) {
						String decryptedFileName = chooser.getSelectedFile().getAbsolutePath();
						// 获得解密后的明文文件名
						decrypt(encryptedFileName, decryptedFileName, password);
						// 调用解密函数
					}
				}
			}
		});
		btnCipherDecrypt.setBounds(369, 288, 89, 21);
		panelCipher.add(btnCipherDecrypt);
		
		textFieldCipherFileName = new JTextField();
		textFieldCipherFileName.setBounds(145, 63, 414, 18);
		panelCipher.add(textFieldCipherFileName);
		textFieldCipherFileName.setColumns(10);
		
		JButton btnCipherOpenFile = new JButton("打开");
		btnCipherOpenFile.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				JFileChooser chooser = new JFileChooser(".");
				// 定义一个FileChooser
				if (chooser.showOpenDialog(FinalWork.this) == JFileChooser.APPROVE_OPTION) {
					// 如果等于成立，可以获得用户选择的文件对象
					String fileName = chooser.getSelectedFile().getAbsolutePath();
					// 定义字符串
					textFieldCipherFileName.setText(fileName);
					// 文件名写入单行文本框

				}
			}
		});
		btnCipherOpenFile.setBounds(35, 62, 79, 21);
		panelCipher.add(btnCipherOpenFile);
		
		JLabel lblCipherPassword = new JLabel("输入口令：");
		lblCipherPassword.setBounds(49, 200, 65, 15);
		panelCipher.add(lblCipherPassword);
		
		passwordFieldCipher = new JPasswordField();
		passwordFieldCipher.setBounds(145, 198, 414, 18);
		panelCipher.add(passwordFieldCipher);
		
		JPanel panelSignature = new JPanel();
		tabbedPane.addTab("签名", null, panelSignature, null);
		panelSignature.setLayout(null);
		
		textFieldSignatureInPut = new JTextField();
		textFieldSignatureInPut.setBounds(105, 69, 428, 18);
		panelSignature.add(textFieldSignatureInPut);
		textFieldSignatureInPut.setColumns(10);
		
		JButton btnSignatureSignedOpenFile = new JButton("...");
		btnSignatureSignedOpenFile.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				JFileChooser chooser = new JFileChooser(".");
				// 定义一个FileChooser
				if (chooser.showOpenDialog(FinalWork.this) == JFileChooser.APPROVE_OPTION) {
					// 如果等于成立，可以获得用户选择的文件对象
					String fileName = chooser.getSelectedFile().getAbsolutePath();
					// 定义字符串
					textFieldSignatureInPut.setText(fileName);
					// 文件名写入单行文本框
				}
			}
		});
		btnSignatureSignedOpenFile.setBounds(554, 68, 35, 21);
		panelSignature.add(btnSignatureSignedOpenFile);
		
		JButton btnSignatureVerify = new JButton("签名验证");
		btnSignatureVerify.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				try {
					Security.addProvider(new BouncyCastleProvider());
					// 创建密钥库对象
					KeyStore keyStore = KeyStore.getInstance("PKCS12", "BC"); 
					
					try (FileInputStream fis = new FileInputStream("./keystores/signkeys.keystore")) {
						// 创建KeyStore对象，并从密钥库文件中读入内容
						char[] password = "123456".toCharArray();
						keyStore.load(fis, password);

						// 读取密钥对mysm2key中的公钥对应的自签名证书，打印证书内容和公钥值
						X509Certificate certificate = (X509Certificate) keyStore
								.getCertificate("mysm2key"); // 获得证书转成X509证书
//					System.out.println("证书基本信息" + certificate); // 打印证书基本信息
						ECPublicKey publicKey = (ECPublicKey) certificate
								.getPublicKey(); // 从证书中获取公钥
//					System.out.println("公钥：" + publicKey);
						
						String fileTosign = textFieldSignatureInPut.getText(); // 被签名的文件名
						String signValueFile = "SignValueStorage.sig"; // 存储签名值的文件名


						// 验证签名
						System.out.println(verifyFile(fileTosign, publicKey, signValueFile));
						
						//如果verifyFile函数返回true，出现弹窗“验证成功”，否则出现“验证失败”
						if (verifyFile(fileTosign, publicKey, signValueFile) == true) {
							JOptionPane.showMessageDialog(FinalWork.this, "验证成功");
						} else {
							JOptionPane.showMessageDialog(FinalWork.this, "验证失败");
						}

					}
				} catch (KeyStoreException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (NoSuchProviderException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (NoSuchAlgorithmException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (CertificateException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (FileNotFoundException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (IOException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (Exception e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
			}
		});
		btnSignatureVerify.setBounds(364, 262, 89, 21);
		panelSignature.add(btnSignatureVerify);
		
		textFieldSignatureValueFile = new JTextField();
		textFieldSignatureValueFile.setBounds(105, 119, 428, 18);
		panelSignature.add(textFieldSignatureValueFile);
		textFieldSignatureValueFile.setColumns(10);
		
		textFieldSignatureKeyFile = new JTextField();
		textFieldSignatureKeyFile.setBounds(105, 175, 428, 18);
		panelSignature.add(textFieldSignatureKeyFile);
		textFieldSignatureKeyFile.setColumns(10);
		
		JLabel lblSignatureSignedFile = new JLabel("被签名文件的文件名：");
		lblSignatureSignedFile.setBounds(36, 46, 139, 15);
		panelSignature.add(lblSignatureSignedFile);
		
		JLabel lblSignatureValueFile = new JLabel("签名值文件名：");
		lblSignatureValueFile.setBounds(36, 92, 139, 15);
		panelSignature.add(lblSignatureValueFile);
		
		JLabel lblSignatureKeyFile = new JLabel("密钥库文件名：");
		lblSignatureKeyFile.setBounds(36, 147, 143, 15);
		panelSignature.add(lblSignatureKeyFile);
		
		JButton btnSignatureGenerate = new JButton("签名生成");
		btnSignatureGenerate.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				try {
					//安全服务提供者
					Security.addProvider(new BouncyCastleProvider());
					// 创建密钥库对象
					KeyStore keyStore = KeyStore.getInstance("PKCS12", "BC"); 
					
					try (FileInputStream fis = new FileInputStream("./keystores/signkeys.keystore")) {
						// 创建KeyStore对象，并从密钥库文件中读入内容
						char[] password = "123456".toCharArray();
						keyStore.load(fis, password); // 将密钥库文件从硬盘读取到KeyStore对象
						
						// 读取密钥对mysm2key中的私钥，创建一个私钥对象，并打印其内容
						KeyStore.ProtectionParameter protParam = new KeyStore.PasswordProtection(
								password); // 把password封装成保护参数对象
						KeyStore.PrivateKeyEntry keyEntry = (PrivateKeyEntry) keyStore
								.getEntry("mysm2key", protParam); // 对keyStore执行getEntry方法
						ECPrivateKey privateKey = (ECPrivateKey) keyEntry
								.getPrivateKey(); 
						// 对keyEntry执行getPrivateKey，真正拿到私钥
//						System.out.println("私钥: " + privateKey.getS());
						String fileTosign = textFieldSignatureInPut.getText(); // 被签名的文件名
						String signValueFile = "SignValueStorage.sig"; // 存储签名值的文件名
						// 签名
						signFile(fileTosign, privateKey, signValueFile);
						
						JOptionPane.showMessageDialog(FinalWork.this, "签名已生成");
					}
					
					
				} catch (KeyStoreException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (NoSuchAlgorithmException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (CertificateException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (UnrecoverableEntryException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (FileNotFoundException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (IOException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (Exception e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
			}
		});
		btnSignatureGenerate.setBounds(116, 262, 89, 21);
		panelSignature.add(btnSignatureGenerate);
		
		JButton btnSignatureKeyOpenFile = new JButton("...");
		btnSignatureKeyOpenFile.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				JFileChooser chooser = new JFileChooser(".");
				// 定义一个FileChooser
				if (chooser.showOpenDialog(FinalWork.this) == JFileChooser.APPROVE_OPTION) {
					// 如果等于成立，可以获得用户选择的文件对象
					String fileName = chooser.getSelectedFile().getAbsolutePath();
					// 定义字符串
					textFieldSignatureKeyFile.setText(fileName);
					// 文件名写入单行文本框
				}
			}
		});
		btnSignatureKeyOpenFile.setBounds(554, 174, 35, 21);
		panelSignature.add(btnSignatureKeyOpenFile);
		
		JButton btnSignatureValueOpenFile = new JButton("...");
		btnSignatureValueOpenFile.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				JFileChooser chooser = new JFileChooser(".");
				// 定义一个FileChooser
				if (chooser.showOpenDialog(FinalWork.this) == JFileChooser.APPROVE_OPTION) {
					// 如果等于成立，可以获得用户选择的文件对象
					String fileName = chooser.getSelectedFile().getAbsolutePath();
					// 定义字符串
					textFieldSignatureValueFile.setText(fileName);
					// 文件名写入单行文本框
				}
			}
		});
		btnSignatureValueOpenFile.setBounds(554, 118, 35, 21);
		panelSignature.add(btnSignatureValueOpenFile);
		
		JButton btnSignature_KeyGenerate = new JButton("密钥对生成");
		btnSignature_KeyGenerate.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				try {
					//添加安全服务提供者
					Security.addProvider(new BouncyCastleProvider());
					// 为SM3WithSM2数字签名算法生成椭圆曲线密钥对
					KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("EC", "BC"); // 创建椭圆曲线密码算法密钥生成器
					ECGenParameterSpec ecGenParameterSpec = new ECGenParameterSpec("sm2p256v1"); // 封装椭圆曲线标准名称
					keyPairGenerator.initialize(ecGenParameterSpec);
					KeyPair keyPair = keyPairGenerator.generateKeyPair();
					// Distinguished Name，即数字证书使用者的身份信息，注意字符串中等号左右不加空格
					String subjectDN = "CN=Chenshuhan, OU=cauc, O=cauc, L=dl, ST=tj, C=cn";
					// 签名算法
					String signatureAlgorithm = "SM3WithSM2";
					// 生成自签名数字证书
					Certificate certificate = selfSign(keyPair, subjectDN,
							signatureAlgorithm);
					// 打印输出数字证书内容
//					System.out.println(certificate);

					// 将密钥对（私钥和自签名数字证书）存入密钥库文件
					KeyStore keyStore = KeyStore.getInstance("PKCS12");
					char[] password = "123456".toCharArray();
					keyStore.load(null, password);
					keyStore.setKeyEntry("mysm2key", keyPair.getPrivate(), password,
							new Certificate[] { certificate });
					try (FileOutputStream fos = new FileOutputStream("./keystores/signkeys.keystore")) {
						keyStore.store(fos, password); // 把内存中的密钥库文件写到硬盘
						JOptionPane.showMessageDialog(FinalWork.this, "密钥对已生成");
					}
				} catch (NoSuchAlgorithmException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (NoSuchProviderException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (InvalidAlgorithmParameterException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (KeyStoreException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (CertificateException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (FileNotFoundException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (IOException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (Exception e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}

			}
		});
		btnSignature_KeyGenerate.setBounds(236, 261, 97, 23);
		panelSignature.add(btnSignature_KeyGenerate);
		
	}
	// 由口令生成指定长度的密钥
		private SecretKeySpec passwordToKey(char[] password, int keyLength) throws NoSuchAlgorithmException {
			byte[] byteArrayOfpassword = new String(password).getBytes();
			MessageDigest md = MessageDigest.getInstance("SHA-256");
			byte[] hashValueOfpassword = md.digest(byteArrayOfpassword);
			return new SecretKeySpec(hashValueOfpassword, 0, keyLength, "SM4");
		}
		
		public void decrypt(String encryptedFileName, String decryptedFileName, char[] password) {
			try {
				FileInputStream fis = new FileInputStream(encryptedFileName);
				// 创建文件输入流，读取密文文件名
				try(fis) {
					int keyLength = fis.read();
					// 从密文文件开头读取密钥长度
					byte[] ivValue = new byte[16];
					// 定义十六个字节的字节数组
					fis.read(ivValue);
					// 从密文文件开头读取IV值
					SecretKeySpec key = passwordToKey(password, keyLength);
					IvParameterSpec iv = new IvParameterSpec(ivValue);
					System.out.println("解密时的IV值：" + Hex.toHexString(ivValue));
					System.out.println("解密时的密钥值：" + Hex.toHexString(key.getEncoded()));
					
					FileOutputStream fos = new FileOutputStream(decryptedFileName);
					// 创建文件输出流
					Cipher cipher = Cipher.getInstance("SM4/OFB/PKCS5Padding");
					cipher.init(Cipher.DECRYPT_MODE, key, iv);
					// 创建并配置Cipher对象
					CipherInputStream cis = new CipherInputStream(fis, cipher);
					// 创建解密输入流，执行解密操作
					try(fos; cis) {
						cis.transferTo(fos);
						JOptionPane.showMessageDialog(FinalWork.this, "解密完成");
					}
				}
			} catch (InvalidKeyException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (HeadlessException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (NoSuchAlgorithmException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (NoSuchPaddingException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidAlgorithmParameterException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}
		
		public void encrypt(String plainFileName, String encyptedFileName,
				char[] password, int keyLength) {

			// 随机生成IV
			byte[] ivValue = new byte[16];
			new SecureRandom().nextBytes(ivValue);
			System.out.println("加密时的IV值：" + Hex.toHexString(ivValue));
			IvParameterSpec iv = new IvParameterSpec(ivValue);
			
			try {
				SecretKeySpec key = passwordToKey(password, keyLength);
				// 调用passwoToKey函数，由口令生成指定长度的密钥
				System.out.println("加密时的密钥：" + Hex.toHexString(key.getEncoded()));
				Cipher cipher = Cipher.getInstance("SM4/OFB/PKCS5Padding");
				cipher.init(Cipher.ENCRYPT_MODE, key, iv);
				// 创建并配置Cipher对象
				FileInputStream fis = new FileInputStream(plainFileName);
				// 创建文件输入流，打开明文文件
				FileOutputStream fos = new FileOutputStream(encyptedFileName);
				// 创建文件输出流，保存密文文件
				
				CipherInputStream cis = new CipherInputStream(fis, cipher);
				// 由普通的文件输入流转成加密输入流
				try(fis; fos; cis){
					fos.write(keyLength);
					// 将密钥长度写入密文开头
					fos.write(ivValue);
					// 将iv值（16个字节的字节数组）写入密文文件开头
					cis.transferTo(fos);
					JOptionPane.showMessageDialog(FinalWork.this, "加密完成");
				}
				//执行加密操作
			} catch (InvalidKeyException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (HeadlessException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (NoSuchAlgorithmException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (NoSuchPaddingException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidAlgorithmParameterException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		// 生成自签名数字证书
		public static Certificate selfSign(KeyPair keyPair, String subjectDN,
				String signatureAlgorithm) throws Exception {
			BouncyCastleProvider bcProvider = new BouncyCastleProvider(); // 添加安全服务提供者
			Security.addProvider(bcProvider);

			long now = System.currentTimeMillis(); // 从1970开始算到现在的毫秒时间
			Date startDate = new Date(now); // 取当前时间，证书有效期开始时间
			X500Name dnName = new X500Name(subjectDN); // 将证书持有人的身份封装对象

			// Using the current time stamp as the certificate serial number
			BigInteger certSerialNumber = new BigInteger(Long.toString(now)); // 将当前时间的长整型变量转成大整数，作为证书序列号

			Calendar calendar = Calendar.getInstance(); // 创建calendar日期对象
			calendar.setTime(startDate);
			calendar.add(Calendar.YEAR, 1); // <-- 1 Yr validity，让数字证书有效时期设为一年
			Date endDate = calendar.getTime(); //证书有效期结束时间

			// 创建内容签名器
			ContentSigner contentSigner = new JcaContentSignerBuilder(
					signatureAlgorithm).build(keyPair.getPrivate());
		
			//创建数字证书生成器
			JcaX509v3CertificateBuilder certBuilder = new JcaX509v3CertificateBuilder(
					dnName, certSerialNumber, startDate, endDate, dnName,
					keyPair.getPublic());
	

			// Extensions --------------------------
			// Basic Constraints true for CA, false for EndEntity
			BasicConstraints basicConstraints = new BasicConstraints(true);
			// Basic Constraints is usually marked as critical.
			certBuilder.addExtension(new ASN1ObjectIdentifier("2.5.29.19"), true, basicConstraints);
			return new JcaX509CertificateConverter().setProvider(bcProvider)
					.getCertificate(certBuilder.build(contentSigner)); // 返回生成的数字证书
			
		}
		/**
		 * 用给定的私钥key对文件fileToSign计算数字签名，将签名值存入signValueFile文件中
		 * 
		 * @param fileToSign: 被签名的文件名
		 * @param key：签名用的私钥
		 * @param signValueFile：存储签名值的文件名
		 */
		public static void signFile(String fileToSign, ECPrivateKey key, String signValueFile) throws Exception {
			try (FileInputStream fis = new FileInputStream(fileToSign);
					FileOutputStream fos = new FileOutputStream(signValueFile)) {
				// 创建数字签名对象
				Signature signature = Signature.getInstance("SM3withSM2");
				// 用私钥初始化数字签名对象，让它做签名生成工作
				signature.initSign(key);
				// 将文件内容加载到数字签名对象上
//				byte[] buffer = fis.readAllBytes();
//				signature.update(fis.readAllBytes());
				byte[] buffer = new byte[1024];
				int n = -1;
				while ((n = fis.read(buffer)) != -1) {
					signature.update(buffer, 0, n);
				}
				// 计算数字签名值
				byte[] signaturValue = signature.sign();
				// 存储数字签名值
				fos.write(signaturValue);
			}
		}

		/**
		 * 验证文件的签名
		 * 
		 * @param fileToVerify：待验证签名的文件名
		 * @param key：验证签名用的公钥
		 * @param signValueFile：存储签名值的文件名
		 * @return true, 签名验证通过, false, 验证验证失败
		 */
		public static boolean verifyFile(String fileToVerify, PublicKey key, String signValueFile) throws Exception {
			try (FileInputStream fisFileToVerify = new FileInputStream(fileToVerify);
					FileInputStream fisSignValueFile = new FileInputStream(signValueFile)) {
				// 创建数字签名对象
				Signature signature = Signature.getInstance("SM3withSM2");
				// 用公钥初始化数字签名对象，让它做签名验证工作
				signature.initVerify(key);
				// 将文件内容加载到数字签名对象上
				byte[] buffer = new byte[1024];
				int n = 0;
				while ((n = fisFileToVerify.read(buffer)) != -1) {
					signature.update(buffer, 0, n);
				}
				// 读取数字签名值
				byte[] signatureValue = fisSignValueFile.readAllBytes();
				// 验证数字签名并返回验证结果
				return signature.verify(signatureValue);
			}
		}
}
